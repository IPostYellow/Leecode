# 图

1. dfs

   ```python
   def dfs(cur,graph,visited):
       '''
       cur:当前结点
       graph:图的邻接表(如果是邻接矩阵需要简单修改下代码)
       visited:用来记录已经访问过的结点
       '''
       if visited[cur]==1:
           return 访问过就不需要再访问了
       visited[cur]=1
       for i in graph[cur]: #访问这个结点连接的下一个结点，不停递归
           dfs(i,graph,visited)
       return 从cur开始的dfs遍历结束
   ```

2. bfs

   ```python
   from queue import Queue
   def bfs(cur,graph,visited):
       '''
       cur:当前结点
       graph:图的邻接表(如果是邻接矩阵需要简单修改下代码)
       visited:用来记录已经访问过的结点
       '''
       if visited[cur]==1:
   		return 访问过了
       que=Queue()
       que.put(cur)
       while not que.empty():
           tmp=que.get()
           visited[tmp]=1
           for i in graph[tmp]:
               if visited[i]!=1:
                   que.put(i)
       return 从cur开始的bfs遍历结束
   ```

   [785.判断二分图](https://github.com/IPostYellow/Leecode/blob/master/%E5%9B%BE/python/785.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE.py)<br>
   思路：通过染色并判断染色是否有冲突的方法来判断是否为二分图。
   ```python
   #dfs方法
   class Solution:
    def dfs(self,cur,prev_color,graph,visited,union_find):
        if cur in visited: #如果遇到了遍历过的结点，要判断遍历过的结点的颜色是否和当前应该有的颜色冲突
            if union_find[cur]==prev_color:
                return False
            else:
                return True
        union_find[cur]=not prev_color
        visited.add(cur)
        return all([self.dfs(i,union_find[cur],graph,visited,union_find) for i in graph[cur]])
    def isBipartite(self, graph: List[List[int]]) -> bool:
        for i in range(len(graph)):
            visited=set()
            union_find=[None]*len(graph)
            if not self.dfs(i,True,graph,visited,union_find):
                return False
        return True
   #bfs方法
   from queue import Queue
   class Solution:
    def bfs(self,cur,graph):
        que=Queue()
        que.put([cur,True]) #队列存储的是二元组列表[当前结点，该结点的父节点的染色]
        visited=set()
        visited.add(cur)
        union_find=[None]*len(graph)
        while not que.empty():
            tmp,prev_color=que.get()
            for i in graph[tmp]:
                if i in visited:
                    if union_find[i]==prev_color:
                        return False
                else:
                    visited.add(i)
                    union_find[i]=not prev_color
                    que.put([i,not prev_color])
        
        return True
    def isBipartite(self, graph: List[List[int]]) -> bool:
        for i in range(len(graph)):
            if not self.bfs(i,graph):
                return False
        return True
   ```
